/**
 * Generated by Serve Engine
 * @author gitesh
 */
package ${service.group.toLowerCase()}.controller;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import ${service.group.toLowerCase()}.exception.BadRequest${service.name.substring(0,1).toUpperCase()}${service.name.substring(1)}ServiceException;
import ${service.group.toLowerCase()}.exception.NotFound${service.name.substring(0,1).toUpperCase()}${service.name.substring(1)}ServiceException;
import ${service.group.toLowerCase()}.query.SearchCriteria;
import ${service.group.toLowerCase()}.query.SearchOperation;
import ${service.group.toLowerCase()}.service.BaseServeService;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.hateoas.ResourceSupport;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

/**
 * @param <RT>
 * 		- Generated Resource Type Class
 * @param <ID>
 * 		- Identifier Type Class
 * @param <S>
 * 		- Implemented BaseServeService Class
 */
public abstract class AbstractServeController<RT extends ResourceSupport, ID, S extends BaseServeService<RT, ID>> {

	@Autowired
	protected S service;

	protected HttpEntity<RT> getById(ID uid, Locale locale) {
		RT resource = service.findByUid(uid, locale)
				.orElseThrow(() -> new NotFound${service.name.substring(0,1).toUpperCase()}${service.name.substring(1)}ServiceException("Object with uid : '" + uid + "' not found!"));
		this.supportHateoas(resource);
		return new ResponseEntity<>(resource, HttpStatus.OK);
	}

	protected HttpEntity<Page<RT>> getAll(Pageable pageable, String query, Locale locale) {
		Page<RT> resources = service.findAll(generateSearchCriteria(query), pageable, locale);
		this.supportHateoas(resources.getContent());
		return new ResponseEntity<>(resources, HttpStatus.OK);
	}

	protected HttpEntity<RT> add(RT resource, Locale locale) {
		RT newResource = service.save(resource, locale);
		this.supportHateoas(newResource);
		return new ResponseEntity<>(newResource, HttpStatus.CREATED);
	}

	protected HttpEntity<RT> overwrite(ID uid, RT resource, Locale locale) {
		RT updated = service.update(uid, resource, locale);
		this.supportHateoas(updated);
		return new ResponseEntity<>(updated, HttpStatus.CREATED);
	}

	protected HttpEntity<?> patch(ID uid, HttpEntity<String> httpEntity, Locale locale) {
		JsonNode jsonNode;
		try {
			jsonNode = new ObjectMapper().readTree(httpEntity.getBody());
		} catch (IOException e) {
			throw new BadRequest${service.name.substring(0,1).toUpperCase()}${service.name.substring(1)}ServiceException("Error translating request body: " + httpEntity.getBody(), e);
		}
		service.patch(uid, jsonNode, locale);
		return new ResponseEntity<>(HttpStatus.NO_CONTENT);
	}

	protected HttpEntity<?> delete(ID uid, Locale locale) {
		service.deleteByUid(uid, locale);
		return new ResponseEntity<>(HttpStatus.NO_CONTENT);
	}

	protected List<SearchCriteria> generateSearchCriteria(String query) {
		List<SearchCriteria> queryParams = new ArrayList<>();
		if (StringUtils.isNotBlank(query)) {
			Pattern pattern = Pattern.compile("(\\w+?)([:!<>~$^*])(\\w+?),");
			Matcher matcher = pattern.matcher(query + ",");
			while (matcher.find()) {
				SearchCriteria criteria = new SearchCriteria();
				criteria.setKey(matcher.group(1));
				criteria.setOperation(SearchOperation.getOperation(matcher.group(2).charAt(0)));
				criteria.setValue(matcher.group(3));
				queryParams.add(criteria);
			}
		}

		return queryParams;
	}

	protected abstract void supportHateoas(RT resource);

	protected void supportHateoas(Collection<RT> resources) {
		if (CollectionUtils.isNotEmpty(resources)) {
			resources.forEach(this::supportHateoas);
		}
	}
}

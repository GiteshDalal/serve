/**
 * Generated by Serve Engine
 *
 * @author gitesh
 */
package ${service.group.toLowerCase()}.service;

import java.util.List;
import java.util.Locale;
import java.util.Optional;

import com.fasterxml.jackson.databind.JsonNode;
import ${service.group.toLowerCase()}.exception.BadRequest${service.name.substring(0,1).toUpperCase()}${service.name.substring(1)}ServiceException;
import ${service.group.toLowerCase()}.exception.NotFound${service.name.substring(0,1).toUpperCase()}${service.name.substring(1)}ServiceException;
import ${service.group.toLowerCase()}.query.ModelSpecification;
import ${service.group.toLowerCase()}.query.SearchCriteria;
import ${service.group.toLowerCase()}.repository.BaseServeRepository;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections.CollectionUtils;
import org.hibernate.HibernateException;
import org.hibernate.hql.internal.ast.QuerySyntaxException;
import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;

/**
 * @param <T>
 * 		- Generated Model Class
 * @param <RT>
 * 		- Generated Respective Resource Class
 * @param <ID>
 * 		- Identifier Class
 * @param <REP>
 * 		- Implemented BaseServeRepository Class
 */
@Slf4j
public abstract class AbstractServeService<T, RT, ID, REP extends BaseServeRepository<T, ID>> implements BaseServeService<RT, ID> {

	public static final String LOG_FORMAT = "[%30s]%12s(%s)";
	private final Class<T> modelClass;
	private final Class<RT> resourceClass;

	@Autowired
	protected REP repo;

	@Autowired
	protected ModelMapper mapper;

	public AbstractServeService(Class<T> modelClass, Class<RT> resourceClass) {
		this.modelClass = modelClass;
		this.resourceClass = resourceClass;
	}

	@Override
	public Optional<RT> findByUid(ID uid, Locale locale) {
		if (log.isDebugEnabled()) {
			log.debug(String.format(LOG_FORMAT, modelClass.getName(), "findByUid", uid + "," + locale));
		}
		Optional<T> entity = repo.findById(uid);
		return entity.map(this::mapToResource);
	}

	@Override
	public Page<RT> findAll(List<SearchCriteria> params, Pageable pageable, Locale locale) {
		if (log.isDebugEnabled()) {
			log.debug(String.format(LOG_FORMAT, modelClass.getName(), "findAll", params + "," + pageable + "," + locale));
		}
		Page<T> page;
		if (CollectionUtils.isNotEmpty(params)) {
			Specification<T> spec = Specification.where(new ModelSpecification<>(params.get(0)));
			for (int i = 1; i < params.size(); i++) {
				spec = spec.and(new ModelSpecification<>(params.get(i)));
			}
			try {
				page = repo.findAll(spec, pageable);
			} catch (QuerySyntaxException e) {
				throw new BadRequest${service.name.substring(0,1).toUpperCase()}${service.name.substring(1)}ServiceException(
						"Invalid operation. Query operation not supported for this field type.", e);
			}
		} else {
			page = repo.findAll(pageable);
		}
		return page.map(this::mapToResource);
	}

	@Override
	public RT save(RT resource, Locale locale) {
		if (log.isDebugEnabled()) {
			log.debug(String.format(LOG_FORMAT, modelClass.getName(), "save", resource + "," + locale));
		}
		T entity;
		try {
			entity = this.mapToModel(resource);
			entity = repo.save(entity);
		} catch (HibernateException e) {
			throw new BadRequest${service.name.substring(0,1).toUpperCase()}${service.name.substring(1)}ServiceException("Invalid input data object. Mandatory field might be missing.", e);
		}
		return this.mapToResource(entity);
	}

	@Override
	public RT update(ID uid, RT resource, Locale locale) {
		if (log.isDebugEnabled()) {
			log.debug(String.format(LOG_FORMAT, modelClass.getName(), "update", uid + "," + resource + "," + locale));
		}
		Optional<T> e = repo.findById(uid);
		if (e.isPresent()) {
			try {
				T entity = mapToModel(resource);
				return mapToResource(repo.save(entity));
			} catch (HibernateException ex) {
				throw new BadRequest${service.name.substring(0,1).toUpperCase()}${service.name.substring(1)}ServiceException("Invalid input data object.", ex);
			}
		} else {
			throw new NotFound${service.name.substring(0,1).toUpperCase()}${service.name.substring(1)}ServiceException("Object with uid : '" + uid + "' not found!");
		}
	}

	@Override
	public void patch(ID uid, JsonNode updates, Locale locale) {
		if (log.isDebugEnabled()) {
			log.debug(String.format(LOG_FORMAT, modelClass.getName(), "patch", uid + "," + updates + "," + locale));
		}
		Optional<T> e = repo.findById(uid);
		if (e.isPresent()) {
			try {
				T entity = e.get();
				mapper.map(updates, entity);
				repo.save(entity);
			} catch (HibernateException ex) {
				throw new BadRequest${service.name.substring(0,1).toUpperCase()}${service.name.substring(1)}ServiceException("Invalid input data object.", ex);
			}
		} else {
			throw new NotFound${service.name.substring(0,1).toUpperCase()}${service.name.substring(1)}ServiceException("Object with uid : '" + uid + "' not found!");
		}
	}

	@Override
	public void deleteByUid(ID uid, Locale locale) {
		if (log.isDebugEnabled()) {
			log.debug(String.format(LOG_FORMAT, modelClass.getName(), "deleteByUid", uid + "," + locale));
		}
		repo.deleteById(uid);
	}

	protected RT mapToResource(T model) {
		return mapper.map(model, resourceClass);
	}

	protected T mapToModel(RT resource) {
		return mapper.map(resource, modelClass);
	}
}

